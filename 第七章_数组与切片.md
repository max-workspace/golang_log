###1.0 声明和初始化
```var arr1 [5]int```
####1.1 数组内元素的类型必须相同
>当数组元素的类型为空接口时，数组元素可以使用不同的类型
####1.2 数组大小必须是固定的并且在声明该数组时就给出
>编译时需要知道数组长度以便分配内存
####1.3 数组长度也是数组类型的一部分
>[5]int和[10]int是属于不同类型的
####1.4 数组的遍历可以采用使用数组长度和自增索引的for循环，也可以直接使用for...range
>采用for...range可以避免数组下标越界产生的panic
####1.5 数组是值类型可以通过 new() 来创建
```golang
var arr1 = new([5]int)
var arr2 [5]int
```
>arr1 的类型是 *[5]int，而 arr2的类型是 [5]int
####1.6 数组可以在创建时进行初始化
```
var arrAge = [5]int{18, 20, 15, 22, 16}
var arrKeyValue = [5]string{3: "Chris", 4: "Ron"}
```
>省略数组长度或将数组长度替换成...初始化得到的就是切片slice
***
###2.0 切片
```golang
var slice1 []type = arr1[start:end]
```
>start省略代表0，end省略代表len(arr1)  
>切片包含start，但不包含end
####2.1 切片是一个引用类型，可以将切片视为数组元素的部分引用
>切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度
####2.2 切片在未初始化之前默认为 nil，长度为 0
####2.3 多个切片如果表示同一个数组的片段，它们可以共享数据
```golang
package main

import "fmt"

func main() {
    a := [5]int {0, 1, 2, 3, 4}
    a1 := a[:]
    a2 := a[:]
    a1[0] = 5
    fmt.Printf("%v\n %v\n %v\n", a, a1, a2)
}
// [5 1 2 3 4]
// [5 1 2 3 4]
// [5 1 2 3 4]
```
####2.4 切片在内存中的组成有三个部分组成，指向相关数组的指针，切片长度以及切片容量
####2.5 绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针!!
####2.6 基于切片的切片
```golang
s2 = s2[1:]
```
>如果 s2 是一个 slice，你可以将 s2 向后移动一位 s2 = s2[1:]，但是末尾没有移动。
>>切片只能向后移动
####2.7 创建一个切片不仅可以依赖于数组进行切片，还可以在数组还没有定义时，通过make() 函数来创建
```golang
slice1 := make([]type, len, cap)
```
>这里 len 是数组的长度并且也是 slice 的初始长度  
>cap 是可选参数
####2.8 new() 和 make() 的区别
```golang
package main

import "fmt"

func main() {
    p1 := new([]int)
    p2 := make([]int, 0)
    // &[]
    fmt.Printf("%t\n", p1)
    // []
    fmt.Printf("%t\n", p2)
}
```
>二者都在堆上分配内存  
>func new(Type) *Type  
>>new(t)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*t类型的值。  
>>它并不初始化内存，只是将其置零  
>>*t指向的内容的值为零，注意并不是指针为零

>func make(t Type, size ...IntegerType) Type
>>返回一个初始化的(而不是置零)，类型为t的值（而不是*t）
***
###3.0 For-range 结构
####3.1 For-range 结构返回值的一个拷贝，不能用来修改原本位置的值
>如果想要修改原始值，请使用arr[index]方式进行修改
```golang
package main

import "fmt"

func main() {
    arr := [5]int{0,1,2,3,4}
    for i, _ := range arr {
        arr[i] *= 2
    }
    // [0 2 4 6 8]
    fmt.Printf("%v", arr)
}
```
####3.2 range使用时前面必须带有 := 
>上例在for...range中的定义的i属于局部变量，作用域只在for...range之中
***
###4.0 切片重组（reslice）
```sl = sl[0:len(sl)+1]```
####4.1 切片可以反复扩展直到占据整个相关数组
***
###5.0 切片的复制与追加
####5.1 copy(dst type, src type)
####5.2 func append(s[]T, x ...T) []T
>如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。
>>append 方法总是返回成功，除非系统内存耗尽了
***
###6.0 字符串、数组和切片的应用
####6.1 从字符串生成字节切片
```golang
// 生成字节切片
c := []byte(s)
copy(dst []byte, src string)
// 生成 rune 的切片
c := []int32(s)
r := []rune(s)
```
####6.2 Go 语言中的字符串是不可变的
>也就是说 str[index] 这样的表达式是不可以被放在等号左侧的  
>>必须先将字符串转换成字节数组，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式
```golang
s := "hello"
c := []byte(s)
c[0] = 'c'
s2 := string(c) // s2 == "cello"
```
####6.3 想要在数组或切片中搜索一个元素，该数组或切片必须先被排序
>因为标准库的搜索算法使用的是二分法
####6.4 切片的底层指向一个数组，只有在没有任何切片指向的时候，底层的数组内存才会被释放，这种特性有时会导致程序占用多余的内存。
>想要避免这个问题，可以通过拷贝copy我们需要的部分到一个新的切片中